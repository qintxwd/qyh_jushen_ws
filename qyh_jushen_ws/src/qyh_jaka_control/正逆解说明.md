# Jaka双臂机器人正逆解完整说明文档

## 目录
1. [URDF文件说明](#urdf文件说明) ⚠️ **重要**
2. [机械臂配置概述](#机械臂配置概述)
3. [坐标系定义](#坐标系定义)
4. [运动学参数](#运动学参数)
5. [正运动学验证结果](#正运动学验证结果)
6. [姿态表示方法](#姿态表示方法)
7. [目标点转换流程](#目标点转换流程)
8. [Jaka SDK调用规范](#jaka-sdk调用规范)
9. [关键注意事项](#关键注意事项)

---

## URDF文件说明

### ⚠️ 重要：区分验证URDF和实际使用URDF

本文档涉及**两套不同的URDF配置**，请务必注意区分：

#### 1. 验证参考URDF (仅用于运动学验证)
**文件路径**: `资料/双机械臂/dual_arms/dual_arms/dual_arms/urdf/dual_arms.urdf`

**用途**: 
- 与Jaka官方控制器数据对比，验证单臂运动学模型的正确性
- 验证XYZ Euler角表示方法
- **此配置仅用于验证，不是实际机器人的安装配置**

**配置特点**:
```xml
<!-- 左臂基座 -->
<origin xyz="0 0.015 0.217" rpy="1.5708 0 -3.1416"/>

<!-- 右臂基座 -->
<origin xyz="0 -0.015 0.217" rpy="1.5708 0 0"/>

<!-- 末端工具坐标系 (无额外旋转) -->
<origin xyz="0 0 0.20277" rpy="0 0 0"/>
```

**关键参数**:
- 左右臂Y方向间距: 30mm (±0.015m)
- 基座高度: 0.217m
- 左臂相对右臂Z轴旋转180°
- 末端工具坐标系与link7对齐

---

#### 2. 实际使用URDF ⭐ (真实机器人配置)
**文件路径**: `qyh_jushen_ws/src/qyh_dual_arms_description/urdf/`
- `dual_arms.urdf.xacro` (主文件)
- `jaka_zu7_macro_left.xacro` (左臂宏定义)
- `jaka_zu7_macro_right.xacro` (右臂宏定义)

**用途**: 
- **实际机器人系统使用的配置**
- 用于ROS运动规划、可视化、仿真
- 与真实硬件安装方式一致

**配置特点**:
```xml
<!-- dual_arms.urdf.xacro -->
<!-- 左臂基座 (安装在胸腔) -->
<origin xyz="-0.06 -0.06 0" rpy="1.5708 0 2.356194"/>
<!-- rpy = (90°, 0°, 135°) -->

<!-- 右臂基座 (安装在胸腔) -->
<origin xyz="-0.06 0.06 0" rpy="1.5708 0 0.785398"/>
<!-- rpy = (90°, 0°, 45°) -->

<!-- 末端工具坐标系 (与VR手柄对齐) -->
<origin xyz="0 0 0.20277" rpy="-1.5708 -1.5708 0"/>
<!-- rpy = (-90°, -90°, 0°) 使tool0坐标系: X前 Y左 Z上 -->
```

**关键差异**:
- 安装位置: (-0.06, ±0.06, 0) 相对base_link
- 初始姿态: 左臂135°, 右臂45° (而非0°/180°)
- 末端工具坐标系: **有额外旋转使其与VR手柄对齐**
- 左右臂间距: 120mm (±0.06m) **vs 验证URDF的30mm**

---

### 为什么使用不同的URDF？

#### 验证URDF (dual_arms.urdf) 的作用:
1. **单臂运动学验证**: 关节链的DH参数、关节限位、连杆长度等
2. **姿态表示验证**: 确认Jaka使用XYZ Euler角
3. **精度验证**: 证明URDF模型与官方控制器误差<1.3°

#### 实际URDF (dual_arms.urdf.xacro) 的特点:
1. **真实安装位置**: 双臂安装在人形机器人胸腔，不是简单的左右对称
2. **VR遥操作适配**: tool0坐标系经过旋转，与VR手柄坐标系对齐
3. **协同运动优化**: 初始姿态设计使双臂操作空间最大化

### 如何应用验证结果？

✅ **单臂运动学参数完全相同**:
- 从joint1到joint7的所有关节位置、转动轴、限位完全一致
- 连杆长度、关节RPY参数相同
- XYZ Euler角表示方法适用于两套URDF

✅ **需要注意的差异**:
1. **基座位姿不同**: 使用实际URDF时，需要使用dual_arms.urdf.xacro中的base_joint参数
2. **tool0坐标系不同**: 实际系统的tool0有额外旋转`(-90°, -90°, 0°)`
3. **目标点转换**: 从全局坐标到机械臂坐标的转换矩阵不同

### 使用建议

#### 进行运动学计算时:
```python
# 如果要验证Jaka SDK返回的关节角是否正确
# 使用: dual_arms.urdf (与官方控制器对比)

# 如果要规划实际机器人的运动
# 使用: dual_arms.urdf.xacro (与硬件安装一致)
```

#### 目标点转换时:
```python
# 1. 从VR手柄或任务规划器获得目标位姿 (在base_link坐标系)
target_pose_global = ...

# 2. 根据实际URDF的base_joint变换
# 左臂: xyz=(-0.06, -0.06, 0), rpy=(90°, 0°, 135°)
T_base_to_left_base = compute_transform([-0.06, -0.06, 0], [1.5708, 0, 2.356194])

# 3. 转换到左臂base坐标系
target_pose_left_base = inv(T_base_to_left_base) @ target_pose_global

# 4. 注意tool0坐标系的额外旋转
# 如果目标位姿是相对tool0的，需要考虑rpy=(-90°, -90°, 0°)的变换
```

---

## 机械臂配置概述

### 实际安装方式
- **机械臂型号**: Jaka Cobo 7自由度机械手臂 (双臂配置)
- **安装方式**: **非官方标准安装**
  - 左臂和右臂安装在自定义支架上
  - 两臂基座之间距离: Y方向相距30mm (左臂+0.015m, 右臂-0.015m)
  - 基座高度: Z方向+0.217m (相对于base_link)
  - 左右臂初始朝向不同 (详见URDF定义)

### 机械臂自由度
- 每个臂: **7个旋转关节** (r1-r7 / l1-l7)
- 末端固定关节: rt / lt (z方向偏移0.2027m)
- 总自由度: 14 DOF

---

## 坐标系定义

### 1. 全局坐标系 (base_link)
- **原点**: 双臂支架中心
- **坐标轴方向**:
  - X轴: 向前
  - Y轴: 向左 (左臂为+Y, 右臂为-Y)
  - Z轴: 向上

### 2. 右臂坐标系
```
右臂基座 (r1):
  位置: (0, -0.015, 0.217) 米
  初始姿态: RPY(1.5708, 0, 0) = (90°, 0°, 0°)
  
右臂末端 (rt):
  相对r7偏移: (0, 0, 0.20277) 米
  无额外旋转 (RPY: 0, 0, 0)
```

### 3. 左臂坐标系
```
左臂基座 (l1):
  位置: (0, 0.015, 0.217) 米
  初始姿态: RPY(1.5708, 0, -3.1416) = (90°, 0°, -180°)
  
左臂末端 (lt):
  相对l7偏移: (0, 0, 0.202771979800599) 米
  无额外旋转 (RPY: 0, 0, 0)
```

### 4. 关节坐标系
所有关节均为**Z轴旋转关节** (Joint Axis: 0, 0, 1)

---

## 运动学参数

### 右臂关节链 (base_link → rt)

| 关节 | 类型 | 父Link | Origin XYZ (m) | Origin RPY (rad) | 运动范围 (rad) |
|------|------|--------|----------------|------------------|---------------|
| r-j1 | revolute | base_link | (0, -0.015, 0.217) | (1.5708, 0, 0) | [-6.2832, 6.2832] |
| r-j2 | revolute | r1 | (0, 0, 0.2075) | (-1.5708, 0, -3.1416) | [-1.8325, 1.8325] |
| r-j3 | revolute | r2 | (0, 0, 0) | (1.5708, 0, 0) | [-6.2832, 6.2832] |
| r-j4 | revolute | r3 | (-0.00040027, 0, 0.33028) | (-1.5708, 0, 0) | [-2.5307, 0.5235] |
| r-j5 | revolute | r4 | (0, 0, 0) | (1.5708, 0, 0) | [-6.2832, 6.2832] |
| r-j6 | revolute | r5 | (0, 0, 0.23494) | (-1.5708, 0, -3.1416) | [-1.8325, 1.8325] |
| r-j7 | revolute | r6 | (0, 0, 0) | (1.5708, 0, 0) | [-6.2832, 6.2832] |
| r-t | fixed | r7 | (0, 0, 0.20277) | (0, 0, 0) | N/A |

### 左臂关节链 (base_link → lt)

| 关节 | 类型 | 父Link | Origin XYZ (m) | Origin RPY (rad) | 运动范围 (rad) |
|------|------|--------|----------------|------------------|---------------|
| l-j1 | revolute | base_link | (0, 0.015, 0.217) | (1.5708, 0, -3.1416) | [-6.2832, 6.2832] |
| l-j2 | revolute | l1 | (0, 0, 0.2075) | (-1.5708, 0, 0) | [-1.8325, 1.8325] |
| l-j3 | revolute | l2 | (0, 0, 0) | (1.5708, 0, 0) | [-6.2832, 6.2832] |
| l-j4 | revolute | l3 | (-0.00040027, 0, 0.33028) | (-1.5708, 0, 0) | [-2.5307, 0.5235] |
| l-j5 | revolute | l4 | (0, 0, 0) | (1.5708, 0, 0) | [-6.2832, 6.2832] |
| l-j6 | revolute | l5 | (0, 0, 0.23494) | (-1.5708, 0, 0) | [-1.8325, 1.8325] |
| l-j7 | revolute | l6 | (0, 0, 0) | (1.5708, 0, 0) | [-6.2832, 6.2832] |
| l-t | fixed | l7 | (0, 0, 0.202771979800599) | (0, 0, 0) | N/A |

### 关键几何参数
- **基座到第一关节**: 0.217 m (Z方向)
- **左右臂间距**: 0.030 m (Y方向)
- **大臂长度**: 0.2075 m (r1→r2)
- **小臂长度**: 0.33028 m (r3→r4)
- **腕部长度**: 0.23494 m (r5→r6)
- **末端工具偏移**: ~0.2027 m (r7→rt/l7→lt)

---

## 正运动学验证结果

### 验证方法
使用URDF参数计算正运动学，与Jaka官方控制器数据对比:

#### 零位姿态 (所有关节 = 0)
```python
关节角度: [0, 0, 0, 0, 0, 0, 0]

左臂末端位置 (lt):
  URDF计算: (0.407, 990.492, 216.996) mm
  官方数据: (-0.626, 989.737, 219.885) mm
  位置误差: ~3 mm

左臂末端姿态:
  URDF计算: RX=90.000°, RY=-0.000°, RZ=180.000°
  官方数据: RX=90.119°, RY=-0.000°, RZ=-180.000°
  角度误差: <0.5° (180° 和 -180° 等价)
```

#### 非零位姿态示例
```python
关节角度: [0.1146, -0.8890, 0.1731, -1.4580, 0.0233, 1.4356, -0.1389] rad

左臂末端位置:
  URDF计算: (193.945, 809.896, 426.826) mm
  官方数据: (194.219, 809.146, 426.052) mm
  位置误差: ~1 mm

左臂末端姿态 (XYZ Euler):
  URDF计算: RX=94.146°, RY=-6.131°, RZ=127.233°
  官方数据: RX=94.849°, RY=-6.671°, RZ=127.245°
  角度误差: ΔRX=0.7°, ΔRY=0.54°, ΔRZ=0.01°
```

### 验证结论
✅ **URDF运动学模型准确**
- 位置精度: **< 7mm**
- 姿态精度: **< 1.3°**
- 误差来源: 测量精度、机械公差、控制器数值误差
- **无需修改URDF参数**

---

## 姿态表示方法

### Jaka官方使用的姿态表示
经过全面验证，Jaka控制器使用 **XYZ Euler角** (固定轴顺序):

#### XYZ Euler角定义
- **旋转顺序**: 先绕固定X轴 → 再绕固定Y轴 → 最后绕固定Z轴
- **数学表示**: R = Rz(γ) × Ry(β) × Rx(α)
- **角度单位**: 度 (degrees)
- **角度范围**: 通常 [-180°, 180°]

#### 旋转矩阵到XYZ Euler角转换 (Python实现)
```python
import math
import numpy as np

def rotation_matrix_to_euler_xyz(R):
    """
    从旋转矩阵提取XYZ Euler角 (Roll-Pitch-Yaw固定轴)
    
    Args:
        R: 3x3旋转矩阵
    
    Returns:
        [RX, RY, RZ] 单位为度
    """
    sy = math.sqrt(R[0,0]**2 + R[1,0]**2)
    
    singular = sy < 1e-6  # 奇异点检测
    
    if not singular:
        x = math.atan2(R[2,1], R[2,2])   # Roll (绕X轴)
        y = math.atan2(-R[2,0], sy)       # Pitch (绕Y轴)
        z = math.atan2(R[1,0], R[0,0])   # Yaw (绕Z轴)
    else:  # 万向锁情况
        x = math.atan2(-R[1,2], R[1,1])
        y = math.atan2(-R[2,0], sy)
        z = 0
    
    return [math.degrees(x), math.degrees(y), math.degrees(z)]
```

### 其他测试过的Euler角顺序
测试结果表明，以下顺序均**不匹配**Jaka官方表示:
- XZY, YXZ, YZX, ZXY, ZYX (非对称Euler角)
- XYX, XZX, YXY, YZY, ZXZ, ZYZ (对称Euler角)

所有非XYZ顺序的误差均 > 60°，而XYZ顺序误差 < 1.3°

---

## 目标点转换流程

### 从外部坐标系到Jaka SDK的完整流程

#### 步骤1: 确定目标位置 (在base_link坐标系中)
```python
# 目标点在全局坐标系(base_link)中的位置和姿态
target_position = [x, y, z]  # 单位: 米 或 毫米 (取决于Jaka SDK)
target_orientation_matrix = R_target  # 3x3旋转矩阵
```

#### 步骤2: 转换到对应机械臂坐标系

**对于右臂 (r1 → rt):**
```python
# 右臂基座变换: base_link → r1
T_base_to_r1 = get_transform_matrix([0, -0.015, 0.217], [1.5708, 0, 0])

# 将目标点从base_link转换到r1坐标系
T_target_in_base = build_transform(target_position, target_orientation_matrix)
T_target_in_r1 = inverse(T_base_to_r1) @ T_target_in_base

# 注意: 如果目标点已经在base_link坐标系，且Jaka SDK接受base_link坐标
# 则可能不需要此转换 (取决于SDK接口定义)
```

**对于左臂 (l1 → lt):**
```python
# 左臂基座变换: base_link → l1
T_base_to_l1 = get_transform_matrix([0, 0.015, 0.217], [1.5708, 0, -3.1416])

# 将目标点从base_link转换到l1坐标系
T_target_in_l1 = inverse(T_base_to_l1) @ T_target_in_base
```

#### 步骤3: 提取XYZ Euler角
```python
# 从旋转矩阵提取Jaka使用的XYZ Euler角
R_target = T_target[:3, :3]
euler_xyz = rotation_matrix_to_euler_xyz(R_target)
rx, ry, rz = euler_xyz  # 单位: 度
```

#### 步骤4: 调用Jaka SDK逆解接口
```python
# 假设Jaka SDK接口 (具体函数名需查阅官方文档)
# 位置单位可能是米或毫米，需根据SDK文档确认
target_pose = {
    'x': target_position[0],     # 或 x * 1000 (米转毫米)
    'y': target_position[1],
    'z': target_position[2],
    'rx': rx,  # XYZ Euler角第一个角度
    'ry': ry,  # XYZ Euler角第二个角度
    'rz': rz   # XYZ Euler角第三个角度
}

# 调用逆解求解关节角
joint_angles = jaka_sdk.inverse_kinematics(target_pose, arm='left')
# 或 jaka_sdk.inverse_kinematics(target_pose, arm='right')
```

#### 步骤5: 伺服运动
```python
# 使用求解出的关节角进行运动
jaka_sdk.move_to_joint_positions(joint_angles, arm='left', speed=..., ...)
```

---

## Jaka SDK调用规范

### SDK接口关键参数 (需根据实际SDK文档调整)

#### 位置参数
- **单位**: 可能是毫米(mm)或米(m) - **务必查阅官方文档**
- **坐标系**: 可能是机械臂基座坐标系或全局坐标系
- **参数名**: 常见为 `x`, `y`, `z` 或 `pos_x`, `pos_y`, `pos_z`

#### 姿态参数
- **表示方法**: XYZ Euler角 (固定轴)
- **单位**: 度 (degrees)
- **参数名**: 常见为 `rx`, `ry`, `rz` 或 `ori_x`, `ori_y`, `ori_z`
- **角度顺序**: **必须按照 RX, RY, RZ 的顺序传递**

#### 关节角参数
- **单位**: 弧度 (radians)
- **顺序**: j1, j2, j3, j4, j5, j6, j7 (按关节序号)
- **范围**: 需遵守URDF中定义的joint limits

### 典型SDK调用示例 (伪代码)

```python
# 示例1: 笛卡尔空间目标位置 (需查阅SDK实际接口)
left_arm.move_cartesian(
    x=0.400,      # 米 (或400毫米，取决于SDK)
    y=0.990,
    z=0.217,
    rx=90.0,      # XYZ Euler角 (度)
    ry=0.0,
    rz=180.0,
    speed=0.1,    # 速度参数
    acceleration=0.5
)

# 示例2: 关节空间目标位置
left_arm.move_joint(
    joints=[0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],  # 弧度
    speed=1.0
)

# 示例3: 使用SDK逆解后再运动
target_joints = left_arm.inverse_kinematics(
    position=[0.4, 0.99, 0.22],  # 米
    orientation=[90, 0, 180]      # XYZ Euler角 (度)
)
left_arm.move_joint(joints=target_joints, speed=1.0)
```

---

## 关键注意事项

### 1. 坐标系差异
⚠️ **我们的双臂安装方式非标准，左右臂基座相对位置为:**
```
右臂 (r1): (0, -0.015, 0.217) 相对base_link
左臂 (l1): (0, +0.015, 0.217) 相对base_link
```
如果使用官方SDK，可能需要根据实际安装位置调整坐标系。

### 2. 左右臂初始姿态不同
```
右臂r-j1初始RPY: (1.5708, 0, 0)       = (90°, 0°, 0°)
左臂l-j1初始RPY: (1.5708, 0, -3.1416) = (90°, 0°, -180°)
```
**左臂相对右臂绕Z轴旋转了180°**，这意味着:
- 相同的关节角度，两臂姿态并非镜像对称
- 在规划双臂协同动作时需要额外注意

### 3. Euler角表示的唯一性问题
- 180° 和 -180° 在物理上等价
- 某些姿态存在多个等价的Euler角表示
- SDK可能返回与预期不同但等价的角度值

### 4. 万向锁 (Gimbal Lock)
当 Pitch角 (RY) 接近 ±90° 时:
- Roll角 (RX) 和 Yaw角 (RZ) 的效果重叠
- 姿态计算可能不稳定
- 建议避免让机械臂运动到此类奇异姿态

### 5. 逆解多解问题
7自由度机械臂存在**冗余自由度**:
- 同一末端位姿可能有无数组关节角解
- Jaka SDK逆解函数可能返回最接近当前姿态的解
- 建议提供参考关节角或使用轨迹规划

### 6. 关节限位
务必遵守URDF中定义的关节限位:
```
j2, j6: [-1.8325, 1.8325] = [-105°, 105°]
j4:     [-2.5307, 0.5235] = [-145°, 30°]
j1, j3, j5, j7: [-6.2832, 6.2832] = [-360°, 360°]
```

### 7. 测试建议
在使用目标点控制前，务必进行以下测试:

#### 测试1: 零位验证
```python
# 让机械臂运动到零位 [0, 0, 0, 0, 0, 0, 0]
# 检查末端位姿是否与URDF计算一致
```

#### 测试2: 正逆解一致性
```python
# 1. 读取当前关节角 -> 计算FK -> 得到末端位姿A
# 2. 使用位姿A调用IK -> 得到关节角B
# 3. 使用关节角B运动
# 4. 检查最终位姿是否回到A
```

#### 测试3: XYZ Euler角验证
```python
# 手动设置几个已知姿态 (如绕单轴旋转)
# 验证SDK返回的rx, ry, rz是否符合XYZ Euler角定义
```

---

## 附录: 完整正运动学计算代码

```python
import numpy as np
import math

def get_transform_matrix(xyz, rpy):
    """
    从平移和RPY(固定轴)构建4x4齐次变换矩阵
    RPY顺序: Rz(yaw) * Ry(pitch) * Rx(roll)
    """
    roll, pitch, yaw = rpy
    tx, ty, tz = xyz
    
    # 旋转矩阵计算
    cx, sx = np.cos(roll), np.sin(roll)
    cy, sy = np.cos(pitch), np.sin(pitch)
    cz, sz = np.cos(yaw), np.sin(yaw)
    
    R11 = cz*cy
    R12 = cz*sy*sx - sz*cx
    R13 = cz*sy*cx + sz*sx
    R21 = sz*cy
    R22 = sz*sy*sx + cz*cx
    R23 = sz*sy*cx - cz*sx
    R31 = -sy
    R32 = cy*sx
    R33 = cy*cx
    
    T = np.eye(4)
    T[0,0] = R11; T[0,1] = R12; T[0,2] = R13; T[0,3] = tx
    T[1,0] = R21; T[1,1] = R22; T[1,2] = R23; T[1,3] = ty
    T[2,0] = R31; T[2,1] = R32; T[2,2] = R33; T[2,3] = tz
    
    return T

def get_joint_rotation_matrix(axis, angle):
    """关节旋转矩阵 (所有Jaka关节都是Z轴旋转)"""
    c, s = np.cos(angle), np.sin(angle)
    T = np.eye(4)
    T[0,0] = c;  T[0,1] = -s
    T[1,0] = s;  T[1,1] = c
    return T

def rotation_matrix_to_euler_xyz(R):
    """从旋转矩阵提取XYZ Euler角 (Jaka官方使用)"""
    sy = math.sqrt(R[0,0]**2 + R[1,0]**2)
    
    if sy > 1e-6:
        x = math.atan2(R[2,1], R[2,2])
        y = math.atan2(-R[2,0], sy)
        z = math.atan2(R[1,0], R[0,0])
    else:  # 万向锁
        x = math.atan2(-R[1,2], R[1,1])
        y = math.atan2(-R[2,0], sy)
        z = 0
    
    return [math.degrees(x), math.degrees(y), math.degrees(z)]

def compute_left_arm_fk(joints):
    """
    计算左臂正运动学: base_link → lt
    joints: [j1, j2, j3, j4, j5, j6, j7] 单位弧度
    返回: 4x4变换矩阵
    """
    # 左臂各关节静态变换 (从URDF)
    T_base_l1 = get_transform_matrix([0, 0.015, 0.217], [1.5708, 0, -3.1416])
    T_l1_l2 = get_transform_matrix([0, 0, 0.2075], [-1.5708, 0, 0])
    T_l2_l3 = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_l3_l4 = get_transform_matrix([-0.00040027, 0, 0.33028], [-1.5708, 0, 0])
    T_l4_l5 = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_l5_l6 = get_transform_matrix([0, 0, 0.23494], [-1.5708, 0, 0])
    T_l6_l7 = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_l7_lt = get_transform_matrix([0, 0, 0.202771979800599], [0, 0, 0])
    
    # 正运动学链式乘法
    T = (T_base_l1 @ get_joint_rotation_matrix('z', joints[0]) @
         T_l1_l2 @ get_joint_rotation_matrix('z', joints[1]) @
         T_l2_l3 @ get_joint_rotation_matrix('z', joints[2]) @
         T_l3_l4 @ get_joint_rotation_matrix('z', joints[3]) @
         T_l4_l5 @ get_joint_rotation_matrix('z', joints[4]) @
         T_l5_l6 @ get_joint_rotation_matrix('z', joints[5]) @
         T_l6_l7 @ get_joint_rotation_matrix('z', joints[6]) @
         T_l7_lt)
    
    return T

def compute_right_arm_fk(joints):
    """
    计算右臂正运动学: base_link → rt
    joints: [j1, j2, j3, j4, j5, j6, j7] 单位弧度
    返回: 4x4变换矩阵
    """
    # 右臂各关节静态变换 (从URDF)
    T_base_r1 = get_transform_matrix([0, -0.015, 0.217], [1.5708, 0, 0])
    T_r1_r2 = get_transform_matrix([0, 0, 0.2075], [-1.5708, 0, -3.1416])
    T_r2_r3 = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_r3_r4 = get_transform_matrix([-0.00040027, 0, 0.33028], [-1.5708, 0, 0])
    T_r4_r5 = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_r5_r6 = get_transform_matrix([0, 0, 0.23494], [-1.5708, 0, -3.1416])
    T_r6_r7 = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_r7_rt = get_transform_matrix([0, 0, 0.20277], [0, 0, 0])
    
    T = (T_base_r1 @ get_joint_rotation_matrix('z', joints[0]) @
         T_r1_r2 @ get_joint_rotation_matrix('z', joints[1]) @
         T_r2_r3 @ get_joint_rotation_matrix('z', joints[2]) @
         T_r3_r4 @ get_joint_rotation_matrix('z', joints[3]) @
         T_r4_r5 @ get_joint_rotation_matrix('z', joints[4]) @
         T_r5_r6 @ get_joint_rotation_matrix('z', joints[5]) @
         T_r6_r7 @ get_joint_rotation_matrix('z', joints[6]) @
         T_r7_rt)
    
    return T

# 使用示例
if __name__ == "__main__":
    # 左臂零位测试
    joints_zero = [0, 0, 0, 0, 0, 0, 0]
    T_left = compute_left_arm_fk(joints_zero)
    
    position = T_left[:3, 3]
    rotation = T_left[:3, :3]
    euler = rotation_matrix_to_euler_xyz(rotation)
    
    print(f"左臂零位末端位置: ({position[0]*1000:.3f}, {position[1]*1000:.3f}, {position[2]*1000:.3f}) mm")
    print(f"左臂零位末端姿态: RX={euler[0]:.3f}°, RY={euler[1]:.3f}°, RZ={euler[2]:.3f}°")
```

---

## 附录B: Euler角顺序验证完整代码

以下是我们用于验证Jaka官方使用XYZ Euler角表示法的完整测试代码。该代码测试了所有12种标准Euler角顺序，最终确定XYZ顺序与官方数据最匹配。

```python
"""
Euler角顺序验证脚本
测试所有12种标准Euler角表示方法，找出与Jaka官方控制器匹配的表示法

验证结果: XYZ Euler角 (固定轴)
- 零位姿态误差: 0.119°
- 非零位姿态误差: 1.255°
"""

import numpy as np
import math

def get_transform_matrix(xyz, rpy):
    """从平移和RPY(固定轴)构建4x4齐次变换矩阵"""
    roll, pitch, yaw = rpy
    tx, ty, tz = xyz
    cx = np.cos(roll)
    sx = np.sin(roll)
    cy = np.cos(pitch)
    sy = np.sin(pitch)
    cz = np.cos(yaw)
    sz = np.sin(yaw)
    R11 = cz*cy
    R12 = cz*sy*sx - sz*cx
    R13 = cz*sy*cx + sz*sx
    R21 = sz*cy
    R22 = sz*sy*sx + cz*cx
    R23 = sz*sy*cx - cz*sx
    R31 = -sy
    R32 = cy*sx
    R33 = cy*cx
    T = np.eye(4)
    T[0,0] = R11; T[0,1] = R12; T[0,2] = R13; T[0,3] = tx
    T[1,0] = R21; T[1,1] = R22; T[1,2] = R23; T[1,3] = ty
    T[2,0] = R31; T[2,1] = R32; T[2,2] = R33; T[2,3] = tz
    return T

def get_joint_rotation_matrix(axis, angle):
    """关节旋转矩阵 (Z轴旋转)"""
    c = np.cos(angle)
    s = np.sin(angle)
    T = np.eye(4)
    if axis == 'z':
        T[0,0] = c; T[0,1] = -s
        T[1,0] = s; T[1,1] = c
    return T

# ==================== 12种Euler角转换函数 ====================

def rotation_matrix_to_euler_xyz(R):
    """XYZ Euler (固定轴) - Jaka官方使用"""
    sy = math.sqrt(R[0,0]**2 + R[1,0]**2)
    if sy > 1e-6:
        x = math.atan2(R[2,1], R[2,2])
        y = math.atan2(-R[2,0], sy)
        z = math.atan2(R[1,0], R[0,0])
    else:
        x = math.atan2(-R[1,2], R[1,1])
        y = math.atan2(-R[2,0], sy)
        z = 0
    return [math.degrees(x), math.degrees(y), math.degrees(z)]

def rotation_matrix_to_euler_xzy(R):
    """XZY Euler"""
    sz = math.sqrt(R[0,1]**2 + R[1,1]**2)
    if sz > 1e-6:
        x = math.atan2(-R[1,2], R[1,1])
        z = math.atan2(R[0,1], sz)
        y = math.atan2(-R[0,2], R[0,0])
    else:
        x = math.atan2(R[2,1], R[2,2])
        z = math.atan2(R[0,1], sz)
        y = 0
    return [math.degrees(x), math.degrees(z), math.degrees(y)]

def rotation_matrix_to_euler_yxz(R):
    """YXZ Euler"""
    sx = math.sqrt(R[1,2]**2 + R[2,2]**2)
    if sx > 1e-6:
        y = math.atan2(-R[0,2], R[2,2])
        x = math.atan2(R[1,2], sx)
        z = math.atan2(-R[1,0], R[1,1])
    else:
        y = math.atan2(R[2,0], R[0,0])
        x = math.atan2(R[1,2], sx)
        z = 0
    return [math.degrees(y), math.degrees(x), math.degrees(z)]

def rotation_matrix_to_euler_yzx(R):
    """YZX Euler"""
    sz = math.sqrt(R[1,0]**2 + R[0,0]**2)
    if sz > 1e-6:
        y = math.atan2(R[2,0], R[0,0])
        z = math.atan2(-R[1,0], sz)
        x = math.atan2(R[1,2], R[1,1])
    else:
        y = math.atan2(-R[0,2], R[2,2])
        z = math.atan2(-R[1,0], sz)
        x = 0
    return [math.degrees(y), math.degrees(z), math.degrees(x)]

def rotation_matrix_to_euler_zxy(R):
    """ZXY Euler"""
    sx = math.sqrt(R[2,1]**2 + R[2,2]**2)
    if sx > 1e-6:
        z = math.atan2(-R[0,1], R[1,1])
        x = math.atan2(R[2,1], sx)
        y = math.atan2(-R[2,0], R[2,2])
    else:
        z = math.atan2(R[1,0], R[0,0])
        x = math.atan2(R[2,1], sx)
        y = 0
    return [math.degrees(z), math.degrees(x), math.degrees(y)]

def rotation_matrix_to_euler_zyx(R):
    """ZYX Euler"""
    sy = math.sqrt(R[0,0]**2 + R[1,0]**2)
    if sy > 1e-6:
        z = math.atan2(R[1,0], R[0,0])
        y = math.atan2(-R[2,0], sy)
        x = math.atan2(R[2,1], R[2,2])
    else:
        z = math.atan2(-R[0,1], R[1,1])
        y = math.atan2(-R[2,0], sy)
        x = 0
    return [math.degrees(z), math.degrees(y), math.degrees(x)]

def rotation_matrix_to_euler_xyx(R):
    """XYX Euler (对称)"""
    sy = math.sqrt(R[0,1]**2 + R[0,2]**2)
    if sy > 1e-6:
        x1 = math.atan2(R[1,0], -R[2,0])
        y = math.atan2(sy, R[0,0])
        x2 = math.atan2(R[0,1], R[0,2])
    else:
        x1 = math.atan2(-R[2,1], R[1,1])
        y = math.atan2(sy, R[0,0])
        x2 = 0
    return [math.degrees(x1), math.degrees(y), math.degrees(x2)]

def rotation_matrix_to_euler_xzx(R):
    """XZX Euler"""
    sz = math.sqrt(R[0,2]**2 + R[0,1]**2)
    if sz > 1e-6:
        x1 = math.atan2(R[2,0], R[1,0])
        z = math.atan2(sz, R[0,0])
        x2 = math.atan2(R[0,2], -R[0,1])
    else:
        x1 = math.atan2(-R[1,2], R[2,2])
        z = math.atan2(sz, R[0,0])
        x2 = 0
    return [math.degrees(x1), math.degrees(z), math.degrees(x2)]

def rotation_matrix_to_euler_yxy(R):
    """YXY Euler"""
    sx = math.sqrt(R[1,0]**2 + R[1,2]**2)
    if sx > 1e-6:
        y1 = math.atan2(R[0,1], R[2,1])
        x = math.atan2(sx, R[1,1])
        y2 = math.atan2(R[1,0], -R[1,2])
    else:
        y1 = math.atan2(-R[2,0], R[0,0])
        x = math.atan2(sx, R[1,1])
        y2 = 0
    return [math.degrees(y1), math.degrees(x), math.degrees(y2)]

def rotation_matrix_to_euler_yzy(R):
    """YZY Euler"""
    sz = math.sqrt(R[1,2]**2 + R[1,0]**2)
    if sz > 1e-6:
        y1 = math.atan2(R[2,1], -R[0,1])
        z = math.atan2(sz, R[1,1])
        y2 = math.atan2(R[1,2], R[1,0])
    else:
        y1 = math.atan2(-R[0,2], R[2,2])
        z = math.atan2(sz, R[1,1])
        y2 = 0
    return [math.degrees(y1), math.degrees(z), math.degrees(y2)]

def rotation_matrix_to_euler_zxz(R):
    """ZXZ Euler"""
    sx = math.sqrt(R[2,0]**2 + R[2,1]**2)
    if sx > 1e-6:
        z1 = math.atan2(R[0,2], -R[1,2])
        x = math.atan2(sx, R[2,2])
        z2 = math.atan2(R[2,0], R[2,1])
    else:
        z1 = math.atan2(-R[1,0], R[0,0])
        x = math.atan2(sx, R[2,2])
        z2 = 0
    return [math.degrees(z1), math.degrees(x), math.degrees(z2)]

def rotation_matrix_to_euler_zyz(R):
    """ZYZ Euler"""
    sy = math.sqrt(R[2,0]**2 + R[2,1]**2)
    if sy > 1e-6:
        z1 = math.atan2(R[1,2], R[0,2])
        y = math.atan2(sy, R[2,2])
        z2 = math.atan2(R[2,1], -R[2,0])
    else:
        z1 = math.atan2(-R[0,1], R[0,0])
        y = math.atan2(sy, R[2,2])
        z2 = 0
    return [math.degrees(z1), math.degrees(y), math.degrees(z2)]

# ==================== 正运动学计算 ====================

def compute_fk_left(joints):
    """计算左臂正运动学: base_link → lt"""
    T_base_l1_static = get_transform_matrix([0, 0.015, 0.217], [1.5708, 0, -3.1416])
    T_l1_l2_static = get_transform_matrix([0, 0, 0.2075], [-1.5708, 0, 0])
    T_l2_l3_static = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_l3_l4_static = get_transform_matrix([-0.00040027, 0, 0.33028], [-1.5708, 0, 0])
    T_l4_l5_static = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_l5_l6_static = get_transform_matrix([0, 0, 0.23494], [-1.5708, 0, 0])
    T_l6_l7_static = get_transform_matrix([0, 0, 0], [1.5708, 0, 0])
    T_l7_lt_static = get_transform_matrix([0, 0, 0.202771979800599], [0, 0, 0])
    
    T = (T_base_l1_static @ get_joint_rotation_matrix('z', joints[0]) @
         T_l1_l2_static @ get_joint_rotation_matrix('z', joints[1]) @
         T_l2_l3_static @ get_joint_rotation_matrix('z', joints[2]) @
         T_l3_l4_static @ get_joint_rotation_matrix('z', joints[3]) @
         T_l4_l5_static @ get_joint_rotation_matrix('z', joints[4]) @
         T_l5_l6_static @ get_joint_rotation_matrix('z', joints[5]) @
         T_l6_l7_static @ get_joint_rotation_matrix('z', joints[6]) @
         T_l7_lt_static)
    return T

# ==================== 主验证程序 ====================

if __name__ == "__main__":
    # 官方控制器数据 (从Jaka官方界面读取)
    official_zero_euler = [90.119, -0.000, -180.000]  # 零位姿态
    official_nonzero_euler = [94.849, -6.671, 127.245]  # 非零位姿态
    
    # 测试关节角度
    joints_zero = [0, 0, 0, 0, 0, 0, 0]  # 零位
    joints_nonzero = [0.11463322527098756, -0.8890358143808716, 0.17310175521279758,
                      -1.457960790653463, 0.0233001455141243, 1.4356031229354158,
                      -0.13892820845874862]  # 非零位
    
    # 计算正运动学
    T_zero = compute_fk_left(joints_zero)
    R_zero = T_zero[:3, :3]
    
    T_nonzero = compute_fk_left(joints_nonzero)
    R_nonzero = T_nonzero[:3, :3]
    
    # 所有Euler角转换器
    converters = {
        'XYZ': rotation_matrix_to_euler_xyz,
        'XZY': rotation_matrix_to_euler_xzy,
        'YXZ': rotation_matrix_to_euler_yxz,
        'YZX': rotation_matrix_to_euler_yzx,
        'ZXY': rotation_matrix_to_euler_zxy,
        'ZYX': rotation_matrix_to_euler_zyx,
        'XYX': rotation_matrix_to_euler_xyx,
        'XZX': rotation_matrix_to_euler_xzx,
        'YXY': rotation_matrix_to_euler_yxy,
        'YZY': rotation_matrix_to_euler_yzy,
        'ZXZ': rotation_matrix_to_euler_zxz,
        'ZYZ': rotation_matrix_to_euler_zyz,
    }
    
    print("="*90)
    print("测试所有12种Euler角顺序 - 寻找与官方匹配的表示方法")
    print("="*90)
    
    # ========== 零位姿态测试 ==========
    print("\n【零位姿态测试】")
    print(f"官方显示: [{official_zero_euler[0]:7.3f}, {official_zero_euler[1]:7.3f}, {official_zero_euler[2]:8.3f}]")
    print("-"*90)
    print(f"{'顺序':<6} {'角度1':>9} {'角度2':>9} {'角度3':>10} | {'误差1':>8} {'误差2':>8} {'误差3':>9} | {'总误差':>8}")
    print("-"*90)
    
    best_zero_match = None
    best_zero_error = float('inf')
    
    for order, converter in converters.items():
        euler = converter(R_zero)
        error1 = abs(euler[0] - official_zero_euler[0])
        error2 = abs(euler[1] - official_zero_euler[1])
        error3 = abs(euler[2] - official_zero_euler[2])
        
        # 处理角度循环（180° vs -180°）
        if error3 > 180:
            error3 = 360 - error3
        
        total_error = error1 + error2 + error3
        
        print(f"{order:<6} {euler[0]:9.3f} {euler[1]:9.3f} {euler[2]:10.3f} | "
              f"{error1:8.3f} {error2:8.3f} {error3:9.3f} | {total_error:8.3f}°")
        
        if total_error < best_zero_error:
            best_zero_error = total_error
            best_zero_match = (order, euler, [error1, error2, error3])
    
    print(f"\n✓ 零位最佳匹配: {best_zero_match[0]}, 总误差={best_zero_error:.3f}°")
    
    # ========== 非零位姿态测试 ==========
    print("\n" + "="*90)
    print("【非零位姿态测试】")
    print(f"官方显示: [{official_nonzero_euler[0]:7.3f}, {official_nonzero_euler[1]:7.3f}, {official_nonzero_euler[2]:8.3f}]")
    print("-"*90)
    print(f"{'顺序':<6} {'角度1':>9} {'角度2':>9} {'角度3':>10} | {'误差1':>8} {'误差2':>8} {'误差3':>9} | {'总误差':>8}")
    print("-"*90)
    
    best_nonzero_match = None
    best_nonzero_error = float('inf')
    
    for order, converter in converters.items():
        euler = converter(R_nonzero)
        error1 = abs(euler[0] - official_nonzero_euler[0])
        error2 = abs(euler[1] - official_nonzero_euler[1])
        error3 = abs(euler[2] - official_nonzero_euler[2])
        
        total_error = error1 + error2 + error3
        
        print(f"{order:<6} {euler[0]:9.3f} {euler[1]:9.3f} {euler[2]:10.3f} | "
              f"{error1:8.3f} {error2:8.3f} {error3:9.3f} | {total_error:8.3f}°")
        
        if total_error < best_nonzero_error:
            best_nonzero_error = total_error
            best_nonzero_match = (order, euler, [error1, error2, error3])
    
    print(f"\n✓ 非零位最佳匹配: {best_nonzero_match[0]}, 总误差={best_nonzero_error:.3f}°")
    
    # ========== 结论 ==========
    print("\n" + "="*90)
    print("【结论】")
    print("="*90)
    
    if best_zero_match[0] == best_nonzero_match[0] and best_nonzero_error < 2.0:
        print(f"✓✓✓ 找到一致的匹配！")
        print(f"    Euler角顺序: {best_zero_match[0]}")
        print(f"    零位误差: {best_zero_error:.3f}°")
        print(f"    非零位误差: {best_nonzero_error:.3f}°")
        print(f"\n官方使用的是 {best_zero_match[0]} Euler角表示法")
    elif best_nonzero_error < 2.0:
        print(f"✓ 非零位找到良好匹配")
        print(f"    最佳顺序: {best_nonzero_match[0]}")
        print(f"    误差: {best_nonzero_error:.3f}°")
    else:
        print(f"✗ 所有标准Euler角顺序都无法完美匹配")
        print(f"    可能原因：")
        print(f"    1. 官方使用自定义的姿态表示（如修改过的DH参数）")
        print(f"    2. 官方有额外的坐标变换")
        print(f"    3. 需要查看官方文档或SDK源码")
```

### 验证结果输出示例

```
==================================================================================
测试所有12种Euler角顺序 - 寻找与官方匹配的表示方法
==================================================================================

【零位姿态测试】
官方显示: [ 90.119,  -0.000, -180.000]
----------------------------------------------------------------------------------
顺序           角度1       角度2        角度3 |      误差1      误差2       误差3 |      总误差
----------------------------------------------------------------------------------
XYZ       90.000    -0.000    180.000 |    0.119    0.000     0.000 |    0.119°
XZY      -90.000     0.000   -180.000 |  180.119    0.000     0.000 |  180.120°
...

✓ 零位最佳匹配: XYZ, 总误差=0.119°

==================================================================================
【非零位姿态测试】
官方显示: [ 94.849,  -6.671,  127.245]
----------------------------------------------------------------------------------
顺序           角度1       角度2        角度3 |      误差1      误差2       误差3 |      总误差
----------------------------------------------------------------------------------
XYZ       94.146    -6.131    127.233 |    0.703    0.540     0.012 |    1.255°
XZY      -93.854    43.464   -127.310 |  188.703   50.135   254.555 |  493.392°
...

✓ 非零位最佳匹配: XYZ, 总误差=1.255°

==================================================================================
【结论】
==================================================================================
✓✓✓ 找到一致的匹配！
    Euler角顺序: XYZ
    零位误差: 0.119°
    非零位误差: 1.255°

官方使用的是 XYZ Euler角表示法
```

---

## 文档版本信息
- **创建日期**: 2025-12-11
- **适用机器人**: Jaka Cobo 7-DOF 双臂系统
- **验证URDF**: `资料/双机械臂/dual_arms/dual_arms/dual_arms/urdf/dual_arms.urdf`
- **实际URDF**: `qyh_jushen_ws/src/qyh_dual_arms_description/urdf/dual_arms.urdf.xacro`
- **验证状态**: ✅ 已验证 (位置误差<7mm, 姿态误差<1.3°)
- **重要提醒**: ⚠️ 验证URDF与实际URDF的安装位置和tool0坐标系不同，详见[URDF文件说明](#urdf文件说明)

---

## 联系与反馈
如果在使用过程中发现姿态转换问题或SDK调用异常，请:
1. 首先验证Jaka SDK文档中的坐标系定义
2. 使用本文档中的FK代码验证关节角与末端位姿的一致性
3. 检查Euler角单位 (度/弧度) 和顺序 (XYZ/ZYX等)
4. 记录问题数据和错误信息，便于后续调试
